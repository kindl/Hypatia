module Common.Array

import Native((&), natIf, Text, isArray, coerce, toString,
    split, insert)
import Common.Base((&), size, eq, (+), identity,
    geti, Unit)


alias Array = Native.Array

# Beware that insert is impure and changes the array
words a = split "%s" a

lines a = split newline a

newline = "
"

filter p a = foldMap (fun e -> if p e then [e] else []) a

copy a = foldl insert [] a

# The first array is copied to avoid inserting the elements into a
append a b = foldl insert (copy a) b

map f a = foldl (fun z e -> insert z (f e)) [] a

foldMap f a = foldl (fun z e -> append z (f e)) [] a

foldl f z a = foldlAux 0 (size a) f z a

foldlAux i maxN f z a =
    natIf (eq i maxN) (fun _ -> z) (fun _ -> foldlAux (i + 1) maxN f (f z (geti i a)) a) Unit

inspect x =
    natIf (isArray x) (fun _ -> "{"
        & foldl (fun z i -> z & " " & inspect i) "" (coerce x)
        & "}") (fun _ -> toString x) Unit 
