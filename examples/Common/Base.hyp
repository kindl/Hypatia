module Common.Base

import Native(Number, Text, Array, Bool,
    (^), (-), (+),
    geti, length, isArray, unsafeCoerce,
    eq, lt, gt, le, ge,
    True, False)

sqrt x = x ^ 0.5

pi = 3.141592653589793

getn n = geti (n - 1)

# Comparison
infix 4 == equals
// Is != the right choice?
// Lua uses ~=, Haskell /= and F# <>
infix 4 != notEquals
infix 4 < lessThan
infix 4 > greaterThan
infix 4 <= lessOrEqal
infix 4 >= greaterOrEqal

equals l r = genComp eq l r

notEquals a b = not_ (equals a b)

lessThan l r = genComp lt l r

greaterThan l r = genComp gt l r

lessThanOrEqual l r = genComp le l r

greaterThanOrEqual l r = genComp ge l r

# Generic comparison
genComp comp l r =
    if comp l r
        then True
        else trySeqComp (genComp comp) l r

trySeqComp comp l r =
    if bothArray l r
        then seqComp comp (toArray l) (toArray r)
        else False
    where
        toArray : a -> Array b
        toArray = unsafeCoerce

bothArray l r =
    if isArray l
        then isArray r
        else False

seqComp comp l r =
    let
        lengthOfL = length l
        lengthOfR = length r
    in if eq lengthOfL lengthOfR
        then seqCompAux comp 0 lengthOfL l r
        else False

seqCompAux comp i maxN l r =
    if eq i maxN
        then True
        else (if comp (geti i l) (geti i r)
            then seqCompAux comp (i + 1) maxN l r
            else False)

repeatN f n =
    if eq n 0 then Unit
        else let { _ = f Unit } in repeatN f (n - 1)

// TODO build a keyword rename mechanism
// not has to be appended with _ because `not` is a keyword in lua
// and would result in a syntax error
not_ True = False
not_ False = True

// TODO create lazy variants
infixr 3 && and_
infixr 2 || or_

and_ : Bool -> Bool -> Bool
and_ False _ = False
and_ True a = a

or_ : Bool -> Bool -> Bool
or_ True _ = True
or_ False a = a

boolToString False = "False"
boolToString True = "True"


type Unit = Unit

type Tuple2 a b = Tuple2 a b

type Tuple3 a b c = Tuple3 a b c

type Tuple4 a b c d = Tuple4 a b c d

type Tuple5 a b c d e = Tuple5 a b c d e

first f (Tuple2 a b) = Tuple2 (f a) b


# Functions
fix f x = f (fix f) x

flip f x y = f y x

identity x = x

infixr 0 <| apply

apply f x = f x

infixl 0 |> reverseApply

reverseApply x f = f x

infixr 9 >> compose

compose f g x = f (g x)

infixr 9 << reverseCompose

reverseCompose = flip compose

always x _ = x

alwaysSecond _ x = x
