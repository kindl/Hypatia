module Common.Base

import Native(Numeral, Text, Array,
    (^), (-), (+),
    geti, size, isArray, coerce,
    natEq, natLt, natIf,
    True, False)

sqrt x = x ^ 0.5

getn n = geti (n - 1)

# Comparison
infix 9 == eq

infixl 4 < lessThan
infixl 4 > greaterThan
infixl 4 <= lessOrEqal
infixl 4 >= greaterOrEqal

eq l r = genComp natEq l r

lessThan l r = genComp natLt l r

# Generic comparison
genComp comp l r =
    primLazyOr (comp l r)
        (fun _ -> trySeqComp (genComp comp) l r)

trySeqComp comp l r =
    primLazyAnd (bothArray l r)
        (fun _ -> seqComp comp (coerce l) (coerce r))

bothArray l r = primLazyAnd (isArray l) (fun _ -> isArray r)

seqComp comp l r =
    let
        lsize = size l
        rsize = size r
    in primLazyAnd (natEq lsize rsize)
        (fun _ -> seqCompAux comp 0 lsize l r)

seqCompAux comp i maxN l r =
    primLazyOr (natEq i maxN) (fun _ ->
        primLazyAnd (comp (geti i l) (geti i r)) (fun _ -> seqCompAux comp (i + 1) maxN l r))

notEq a b = not_ (eq a b)

primLazyOr x f = natIf x (fun _ -> x) f Unit

primLazyAnd x f = natIf x f (fun _ -> x) Unit

repeatN f n =
    natIf (natEq n 0) (fun _ -> Unit) (fun _ -> let { _ = f Unit } in repeatN f (n - 1)) Unit

# Basic Types
type Option a = None | A a

lazyAnd x f = if x then f Unit else x

lazyOr x f = if x then x else f Unit

not_ True = False
not_ False = True

boolToString False = "False"
boolToString True = "True"

type Unit = Unit

type Tuple a b = Tuple a b

# Functions
fix f x = f (fix f) x


infixr 0 <| reverseApply

reverseApply f a = f a


infixl 0 |> apply

apply a f = f a


identity x = x

compose f g x = f (g x)
