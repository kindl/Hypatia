module Common.Json

import Native(Number, Text, Array,
    (++), (+), (-),
    toString, Bool, True, False)
import Common.Base(Tuple2)
import Common.Text(toArray)
import Common.Parser((*>), (<*), (<|>),
    parse, parseTilEnd, token, text,
    string, double, array, skipAnySpace,
    map2, map, sepBy, point)
import Common.Array(intercalate, foldl)
import Common.Array as Array
import Abstract.State(defer)


parseJson s = parseTilEnd (value <* skipAnySpace) s


type JsonValue = JsonNumber Number
    | JsonString Text
    | JsonObject (Array (Tuple2 Text JsonValue))
    | JsonArray (Array JsonValue)
    | JsonBool Bool
    | JsonNull


pretty (JsonNumber n) = toString n
pretty (JsonArray a) = "[" ++ intercalate ", " (Array.map pretty a) ++ "]"
pretty (JsonString s) = prettyString s
pretty (JsonObject o) =
    "{" ++ intercalate ", " (Array.map (\(Tuple2 k v) -> prettyString k ++ ": " ++ pretty v) o) ++ "}"

prettyString s = "\"" ++ escape s ++ "\""

escape s = foldl (\acc c -> acc ++ (escapeSingle c)) "" (toArray s)

escapeSingle "\n" = "\\n"
escapeSingle "\t" = "\\t"
escapeSingle "\r" = "\\r"
escapeSingle "\\" = "\\\\"
escapeSingle c = c

object kv = token "{" *> sepBy kv (token ",") <* token "}"

keyValuePair v = map2 Tuple2 string (text ":" *> v)

// The defer is necessary, because value depends on itself
value = defer (\_ ->
        map JsonObject (object (keyValuePair value)) <|> map JsonArray (array value))
    <|> map JsonString string
    <|> map JsonNumber double
    <|> map JsonBool ((token "true" *> point True) <|> (token "false" *> point False))
    <|> (token "null" *> point JsonNull)
