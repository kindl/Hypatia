module Common.Parser

import Native((++), (+), (-),
    True, Array, Text,
    textLength, toNumber)
import Common.Base((==), (!=), (>>),
    Tuple2,
    not)
import Common.Text(safeSubstring, toArray)
import Common.Array(elem, flat)
import Common.Option(Some, None, unsafeFromOption)
import Common.Option as Option
import Abstract.State(StateT, runStateT)
import Abstract.State as State
import Abstract.Applicative as Applicative
import Abstract.Functor as Functor
import Abstract.Alternative as Alternative


point = State.point Option.point

bind m f = State.bind Option.bind m f


infixr 3 <|> alternative

(<|>) = State.alternative f
    where f p1 p2 = (\s ->
        case p1 s of
            None -> p2 s
            result -> result
        )

many p = Alternative.many point map2 alternative State.defer p

many1 p = Alternative.many1 point map2 alternative State.defer p

sepBy p sep = Alternative.sepBy point map2 alternative State.defer p sep

sepBy1 p sep = Alternative.sepBy1 point map2 alternative State.defer p sep

optional p = Alternative.optional point map alternative

option = Alternative.option point alternative


map f a = Applicative.map point map2 f a

map2 f a1 a2 = bind a1 (\r1 -> bind a2 (\r2 -> point (f r1 r2)))

map3 f a1 a2 a3 = Applicative.map3 map2 f a1 a2 a3

map4 f a1 a2 a3 a4 = Applicative.map4 map2 f a1 a2 a3 a4

infixl 4 <*> apply

infixl 4 <* applyFirst

infixl 4 *> applySecond

(<*>) = Applicative.apply map2

(*>) = Applicative.applySecond map2

(<*) = Applicative.applyFirst map2


parse p s = runStateT p (Tuple2 s 0)

parseTilEnd p s = case parse p s of
    Some (Tuple2 result (Tuple2 _ position)) ->
        if position == textLength s
            then Some result
            else None
    None -> None


// Combinators
takeWhile pred = map flat (many (satisfy pred))

takeWhile1 pred = map flat (many1 (satisfy pred))


text t = StateT (fun (Tuple2 input position) ->
    let { l = position + textLength t } in
        case safeSubstring input position (l - 1) of
            Some part -> if t == part
                then Some (Tuple2 part (Tuple2 input l))
                else None
            None -> None
        )

satisfy p = StateT (fun (Tuple2 input position) ->
    case safeSubstring input position position of
        Some part -> if p part
            then Some (Tuple2 part (Tuple2 input (position + 1)))
            else None
        None -> None
    )

// Helpers for splitting text
split sep s =
    unsafeFromOption (parseTilEnd (sepBy (takeWhile ((!=) sep)) (text sep)) s)

words s =
    unsafeFromOption (parseTilEnd
        (skipAnySpace *> sepBy (takeWhile1 (not >> isAnySpace)) (takeWhile1 isAnySpace) <* skipAnySpace) s)

lines s = split "\n" s


space = text " "

tab = text "\t"

newline = text "\n"

skipAnySpace = takeWhile isAnySpace

spaceArray = toArray " \t\n\r"

isAnySpace c = elem c spaceArray


token t = skipAnySpace *> text t


array p = token "[" *> sepBy p (token ",") <* token "]"

parens p = token "(" *> p <* token ")"

escapeCharacter = (text "\\\\" *> point "\\")
    <|> (text "\\n" *> point "\n")
    <|> (text "\\r" *> point "\r")
    <|> (text "\\t" *> point "\t")

string =
    token "\""
    *> map flat (many (escapeCharacter <|> satisfy ((!=) "\"")))
    // This uses text on purpose to not consume any spaces before a double quote
    <* text "\""

double = map4 (\x y z u -> toNumber (x ++ y ++ z ++ u))
    (option "" (text "-"))
    digits
    (option "" fraction)
    (option "" exponent)

fraction = map2 (++)
    (text ".")
    digits

exponent = map3 (\x y z -> x ++ y ++ z)
    (text "e" <|> text "E")
    (option "" (text "+" <|> text "-"))
    digits

digitArray = toArray "0123456789"

isDigit c = elem c digitArray

digits = takeWhile1 isDigit
