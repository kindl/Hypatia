module Common.Parser

import Native((++), (+), (-),
    True, Array, Text,
    textLength, toNumber, substring)
import Common.Base((==), (!=), (>>), (>=), (||),
    Tuple2, Tuple3,
    not)
import Common.Text(toArray)
import Common.Array(elem, flat)
import Common.Option(Some, None, unsafeFromOption)
import Common.Option as Option
import Abstract.State(StateT, runStateT)
import Abstract.State as State
import Abstract.Applicative as Applicative
import Abstract.Functor as Functor
import Abstract.Alternative as Alternative


point = State.point Option.point

bind m f = State.bind Option.bind m f


infixr 3 <|> alternative

(<|>) p1 p2 = StateT (\s ->
    case runStateT p1 s of
        None -> runStateT p2 s
        r -> r
    )

many = Alternative.many point map2 alternative State.defer

many1 = Alternative.many1 point map2 alternative State.defer

sepBy = Alternative.sepBy point map2 alternative State.defer

sepBy1 = Alternative.sepBy1 point map2 alternative State.defer

optional = Alternative.optional point map alternative

option = Alternative.option point alternative


map = Applicative.map point map2

map2 f a1 a2 = bind a1 (\r1 -> bind a2 (\r2 -> point (f r1 r2)))

map3 = Applicative.map3 map2

map4 = Applicative.map4 map2

infixl 4 <*> apply

infixl 4 <* applyFirst

infixl 4 *> applySecond

(<*>) = Applicative.apply map2

(*>) = Applicative.applySecond map2

(<*) = Applicative.applyFirst map2


parse p s = runStateT p (Tuple3 s 0 (textLength s))

parseTilEnd p s = case parse p s of
    Some (Tuple2 result (Tuple3 _ position len)) ->
        if position == len
            then Some result
            else None
    None -> None


// Combinators
text t = StateT (\(Tuple3 input position len) ->
    let
        partLength = position + textLength t - 1
    in if position >= len || partLength >= len then None else
        let
            part = substring input position partLength
        in (if t == part
            then Some (Tuple2 part (Tuple3 input (partLength + 1) len))
            else None)
    )

takeWhile pred = takeWhileAux (many (satisfy pred))

takeWhile1 pred = takeWhileAux (many1 (satisfy pred))

takeWhileAux p = StateT (\(Tuple3 input position len) ->
    case runStateT p (Tuple3 input position len) of
        Some (Tuple2 _ (Tuple3 _ newPosition _)) ->
            let
                part = substring input position (newPosition - 1)
            in Some (Tuple2 part (Tuple3 input newPosition len))
        None -> None
    )

satisfy p = StateT (\(Tuple3 input position len) ->
    if position >= len then None else
        let
            part = substring input position position
        in (if p part
            then Some (Tuple2 part (Tuple3 input (position + 1) len))
            else None)
    )

// Helpers for splitting text
split sep s =
    unsafeFromOption (parseTilEnd (sepBy (takeWhile ((!=) sep)) (text sep)) s)

words s =
    unsafeFromOption (parseTilEnd
        (skipAnySpace *> sepBy (takeWhile1 (not >> isAnySpace)) (takeWhile1 isAnySpace) <* skipAnySpace) s)

lines s = split "\n" s


space = text " "

tab = text "\t"

newline = text "\n"

skipAnySpace = takeWhile isAnySpace

spaceArray = toArray " \t\n\r"

isAnySpace c = elem c spaceArray


escapeCharacter = (text "\\\\" *> point "\\")
    <|> (text "\\n" *> point "\n")
    <|> (text "\\r" *> point "\r")
    <|> (text "\\t" *> point "\t")
    <|> (text "\\\"" *> point "\"")

string =
    text "\""
    *> map flat (many (escapeCharacter <|> takeWhile1 ((!=) "\"")))
    <* text "\""

double = map4 (\x y z u -> toNumber (x ++ y ++ z ++ u))
    (option "" (text "-"))
    digits
    (option "" fraction)
    (option "" exponent)

fraction = map2 (++)
    (text ".")
    digits

exponent = map3 (\x y z -> x ++ y ++ z)
    (text "e" <|> text "E")
    (option "" (text "+" <|> text "-"))
    digits

digitArray = toArray "0123456789"

isDigit c = elem c digitArray

digits = takeWhile1 isDigit
