module Common.Parser

import Native((++), (+), (-),
    True, Array, Text,
    textLength, toNumber, substring)
import Common.Base((==), (!=), (>>),
    Tuple2,
    not)
import Common.Text(safeSubstring, toArray)
import Common.Array(elem, flat)
import Common.Option(Some, None, unsafeFromOption)
import Common.Option as Option
import Abstract.State(StateT, runStateT)
import Abstract.State as State
import Abstract.Applicative as Applicative
import Abstract.Functor as Functor
import Abstract.Alternative as Alternative


point = State.point Option.point

bind m f = State.bind Option.bind m f


infixr 3 <|> alternative

(<|>) p1 p2 = StateT (\s ->
    case runStateT p1 s of
        None -> runStateT p2 s
        r -> r
    )

many = Alternative.many point map2 alternative State.defer

many1 = Alternative.many1 point map2 alternative State.defer

sepBy = Alternative.sepBy point map2 alternative State.defer

sepBy1 = Alternative.sepBy1 point map2 alternative State.defer

optional = Alternative.optional point map alternative

option = Alternative.option point alternative


map = Applicative.map point map2

map2 f a1 a2 = bind a1 (\r1 -> bind a2 (\r2 -> point (f r1 r2)))

map3 = Applicative.map3 map2

map4 = Applicative.map4 map2

infixl 4 <*> apply

infixl 4 <* applyFirst

infixl 4 *> applySecond

(<*>) = Applicative.apply map2

(*>) = Applicative.applySecond map2

(<*) = Applicative.applyFirst map2


parse p s = runStateT p (Tuple2 s 0)

parseTilEnd p s = case parse p s of
    Some (Tuple2 result (Tuple2 _ position)) ->
        if position == textLength s
            then Some result
            else None
    None -> None


// Combinators
text t = StateT (\(Tuple2 input position) ->
    let { l = position + textLength t } in
        case safeSubstring input position (l - 1) of
            Some part -> if t == part
                then Some (Tuple2 part (Tuple2 input l))
                else None
            None -> None
        )

takeWhile pred = takeWhileAux (many (satisfy pred))

takeWhile1 pred = takeWhileAux (many1 (satisfy pred))

takeWhileAux p = StateT (\(Tuple2 input position) ->
    case runStateT p (Tuple2 input position) of
        Some (Tuple2 _ (Tuple2 _ newPosition)) ->
            let
                part = substring input position (newPosition - 1)
            in Some (Tuple2 part (Tuple2 input newPosition))
        None -> None
    )

satisfy p = StateT (\(Tuple2 input position) ->
    case safeSubstring input position position of
        Some part -> if p part
            then Some (Tuple2 part (Tuple2 input (position + 1)))
            else None
        None -> None
    )

// Helpers for splitting text
split sep s =
    unsafeFromOption (parseTilEnd (sepBy (takeWhile ((!=) sep)) (text sep)) s)

words s =
    unsafeFromOption (parseTilEnd
        (skipAnySpace *> sepBy (takeWhile1 (not >> isAnySpace)) (takeWhile1 isAnySpace) <* skipAnySpace) s)

lines s = split "\n" s


space = text " "

tab = text "\t"

newline = text "\n"

skipAnySpace = takeWhile isAnySpace

spaceArray = toArray " \t\n\r"

isAnySpace c = elem c spaceArray


escapeCharacter = (text "\\\\" *> point "\\")
    <|> (text "\\n" *> point "\n")
    <|> (text "\\r" *> point "\r")
    <|> (text "\\t" *> point "\t")
    <|> (text "\\\"" *> point "\"")

string =
    text "\""
    *> map flat (many (escapeCharacter <|> takeWhile1 ((!=) "\"")))
    <* text "\""

double = map4 (\x y z u -> toNumber (x ++ y ++ z ++ u))
    (option "" (text "-"))
    digits
    (option "" fraction)
    (option "" exponent)

fraction = map2 (++)
    (text ".")
    digits

exponent = map3 (\x y z -> x ++ y ++ z)
    (text "e" <|> text "E")
    (option "" (text "+" <|> text "-"))
    digits

digitArray = toArray "0123456789"

isDigit c = elem c digitArray

digits = takeWhile1 isDigit
