module Game

import Prelude((/), Tuple, Unit, getn,
    Numeral, Array, insert, compose, write)
import Obj(getFaces, getVertices, getNormals,
    VTNI, VNI, VTI, VI)
import Geometry(Vec4, translateMatrix, scaleMatrix, simpleProjectionMatrix,
    rotationZ, rotationY, rotationX,
    normalize, to2d, multiply, transform)
import Array(map, foldMap, inspect)
import Common.Stateful(Ref, unsafeMakeRef, unsafeRun, writeRef, readRef)


# Primitives
polygon : Array Numeral -> Unit

uncurry5 : a -> b -> c -> d -> e -> f -> Native.Fun5 a b c d e f

gameState : Ref (Array (Array Numeral))
gameState = unsafeMakeRef []

setState x = unsafeRun (writeRef gameState x)

withState f = f (unsafeRun (readRef gameState))

pi = 3.141592653589793

## Load
model = Obj.load "cube.obj"

screenWidth = 800
screenHeight = 600
t = translateMatrix (screenWidth / 2) (screenHeight / 2) 0
s = scaleMatrix (screenHeight / 2)
r = rotationZ pi

modelview = multiply t (multiply r s)
projection = simpleProjectionMatrix 5000
 
lightDirection = normalize (Vec4 0 0 1 0)

faces = getFaces model

vertices = getVertices model

getPoint (VTNI v _ _) = getn v vertices
getPoint (VNI v _) = getn v vertices
getPoint (VTI v _) = getn v vertices
getPoint (VI v) = getn v vertices

transformPoint rotation vector =
    let
        rotated = transform rotation vector
        transformed = transform modelview rotated
        projected = transform projection transformed
        divided = to2d projected
    in divided

mousemoved = uncurry5 mousemovedC

mousepressed _ = withState (fun x -> write (inspect x))

mousemovedC x y dx dy isTouch =
    let
        rotY = rotationY (x / screenWidth)
        rotX = rotationX (y / screenHeight)
        rotation = multiply rotY rotX
    in setState (map (compose tuplesToArray (transformFace rotation)) faces)

transformFace rotation face = map (compose (transformPoint rotation) getPoint) face

draw _ = withState (map polygon)

tuplesToArray = foldMap tupleToArray
tupleToArray (Tuple a b) = [a, b]
